* There is a double write after a wait?!
	If the wait has not had a zero output before then the data after the wait is output again



* Need to find what is keeping the data file open each time



* At the moment inside DsimModel.cpp there is untested logic for "mTryGetData" and when to respond to a successful wait waitingForInput() by getting the next data value



* Add defines, simple key value replacement
	* #string value




* Create an application that renders a digital logic analyser that listens on a specific network port for data.
	Then the digital data model in record mode can optionally send to this specific network port.
	This would allow multiple instances of the logic analyser to run and not be part of the main Proteus process (if Proteus crashes the capture windows are still open, which is useful)
	Also any breakpoints hit in Proteus will not stop the logic analyser window from working.
	Each instance can have an optional config file that remembers the input signal groups, names, colours etc
	Capture on pattern...
	Clear display when a new run is starting, or append to current display, clear display button
	With up to 32 signals for each window, this would be a minimum of 8 bytes for the time, plus 4 bytes for all signals, for each coincident update.
	* Command line to generate pattern data on a timer, to allow the update rendering to be tested
	* Command line option to limit the number of captures
		> Captures are stored in a round robin list making it easy and fast to search
		> When searching to find the current scroll start time, a binary search from the last position can be used
		>> -n 1000000
			The maximum number of entries to store
		>> -f 50.0
			How much buffer to keep before the first trigger.
	* Command line options to customise the display of the 32 signals
		> Zoom, the initial time period (in seconds by default) displayed in the width of the window: -z <time as a floating point value>
		> Apply names for each group
		> Binary/Hex/Decimal display
		> Group: -g <"Name here"> <b/d/h> <./! separated list of signal numbers in decimal>
			Displays an address bus value in hex from the signals (in their defined little endian ordering, numbers can be prefixed with 0), where 11-15 are inverted before display: -g "address bus" h .6.1.3.00.4.5.06.07.08.9.10!11!12!13!14!15
	* Toolbar button to clear current data
	* Status bar to display the start time of the buffer
		> end time
		> time delta
		> buffer fill status
	* Command line option to define trigger conditions
		> Trigger group: -tg <"the name"> <b/d/h> <value>
			Triggers on group "the name" reaching the hex value "ce1": -tg "the name" h ce1
		> Trigger on signal edge: -te <+/-><signal number>
		> Where capturing will then stop after the buffer is full
		> Pre-fill buffer limit defines how much data we can capture to after trigger
		> There could be more than one trigger in a capture buffer, render these
		> Toolbar buttons to seek to the prev/next state change
		> Toolbar buttons to seek to the prev/next trigger
		> Toolbar button to enable the trigger again, capturing more data (don't clear old data)
	* When receiving an update and the button "last" is pressed, then force the window scroll to the right hand end
	* Receive updates from VSMDigitalData network connection
	* Inspect the memory of the getdsimpin() result, see if there is a signal name in there.




* RELTIME IINSTANCE::getdelay and getboolval might be more useful for values like TOLOW THENTOHI etc
	However these would need to be strings, not floats. e.g. {CLOCKRATE="Clock Rate",STRING}
	> Check the existing values like 0.0001 are automaically converted to the correct delay
	> Also it would probably be better to keep the delays as RELTIME or ABSTIME for more accurate usage with setstate()
	For mInstance->




